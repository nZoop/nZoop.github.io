<html>
  <head>
    <script
      src="https://code.jquery.com/jquery-3.4.1.min.js"
      integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.min.js"
      integrity="sha256-4iQZ6BVL4qNKlQ27TExEhBN1HFPvAvAMbFavKKosSWQ="
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/chart.js@2.9.3/dist/Chart.min.js"
      integrity="sha256-R4pqcOYV8lt7snxMQO/HSbVCFRPMdrhAFMH+vr9giYI="
      crossorigin="anonymous"
    ></script>
  </head>
  <body>
    <div width="95%">
      <canvas id="cChart1"></canvas>
    </div>
    <div width="95%">
      <canvas id="cChart2"></canvas>
    </div>
    <script>
      const labels = {
        en: {
          chart: 'Spread of COVID-19 in Finland',
          bars: 'New infections per day [bars]',
          line: 'Total number of infected [line]',
          iLine: 'confirmed infections',
          trend: 'projected infections',
          population: '% of population gets infected',
          growth: 'growth rate',
        },
        fi: {
          chart: 'Koronaviruksen levinneisyys suomessa',
          bars: 'Päivittäiset tartunnat [pylväät]',
          line: 'Tartunnansaaneiden kokonaismäärä [viiva]',
          iLine: 'varmistetut tartunnat',
          trend: 'ennustetut tartunnat',
          population: '% väestöstä sairastuu',
          growth: 'kasvunopeus',
        },
      }[navigator.language.slice(0, 2)]
      const population = 5540000
      const predictMonths = 6
      const infectionLineDataset = {
        data: [{ t: moment(), y: 0 }],
        legend: {
          text: labels.iLine,
          fillStyle: 'rgba(230, 90, 20, 0.5)',
          strokeStyle: 'rgb(230, 90, 20)',
          lineJoin: 'round',
        },
        order: 1,
        type: 'line',
        fill: false,
        borderColor: 'rgb(230, 90, 20)',
        pointRadius: 0,
        xAxisID: 'time-axis-0',
        yAxisID: 'total-axis',
      }
      const infectionBarDataset = {
        data: [{ t: moment(), y: 0 }],
        type: 'bar',
        order: 10,
        backgroundColor: 'rgba(230, 90, 20, 0.5)',
        barPercentage: 0.3,
        gridLines: { offsetGridLines: false },
        xAxisID: 'time-axis-0',
        yAxisID: 'new-axis',
      }
      const trendlineDataset = {
        data: [{ t: moment(), y: 0 }],
        legend: {
          text: labels.trend,
          fillStyle: 'rgba(240, 180, 40, 0.4)',
          strokeStyle: 'rgb(240, 180, 40)',
          lineDash: [8, 4],
          lineJoin: 'round',
        },
        type: 'line',
        order: 2,
        fill: false,
        borderColor: 'rgb(240, 180, 40)',
        borderDash: [10, 5],
        pointRadius: 0,
        xAxisID: 'time-axis-0',
        yAxisID: 'total-axis',
      }
      const trendbarDataset = {
        data: [{ t: moment(), y: 0 }],
        type: 'bar',
        order: 11,
        backgroundColor: 'rgba(240, 180, 40, 0.4)',
        barPercentage: 0.5,
        gridLines: { offsetGridLines: false },
        xAxisID: 'time-axis-0',
        yAxisID: 'new-axis',
      }

      const predictionLineDataset = (num, percentage, rate) => ({
        data: [{ t: moment(), y: 0 }],
        legend: {
          text: `${percentage}${labels.population}, ${labels.growth} ${rate}%`,
          fillStyle: `rgba(${160 + num * 20}, ${125 + num * 25}, ${180 +
            num * 10}, 0.6)`,
          strokeStyle: `rgb(${160 + num * 20}, ${125 + num * 25}, ${180 +
            num * 10})`,
          lineDash: [8, 4],
          lineJoin: 'round',
        },
        type: 'line',
        order: 5 + num,
        fill: false,
        borderColor: `rgb(${160 + num * 20}, ${125 + num * 25}, ${180 +
          num * 10})`,
        borderDash: [10, 5],
        pointRadius: 0,
        xAxisID: 'time-axis-0',
        yAxisID: 'total-axis',
        datasetNumber: num,
        infectionPercentage: percentage,
        infectionRate: rate,
      })
      const predictionLineDatasets = [
        predictionLineDataset(1, 65, 8),
        predictionLineDataset(2, 50, 5),
        predictionLineDataset(3, 40, 3),
      ]
      const predictionBarDataset = (num, percentage, rate) => ({
        data: [{ t: moment(), y: 0 }],
        type: 'bar',
        order: 15 + num,
        backgroundColor: `rgba(${160 + num * 20}, ${125 + num * 25}, ${180 +
          num * 10}, 0.6)`,
        barPercentage: 0.55 + 0.15 * num,
        xAxisID: `time-axis-${num}`,
        yAxisID: 'new-axis',
        gridLines: { offsetGridLines: false },
        datasetNumber: num,
        infectionPercentage: percentage,
        infectionRate: rate,
      })
      const predictionBarDatasets = [
        predictionBarDataset(1, 65, 8),
        predictionBarDataset(2, 50, 5),
        predictionBarDataset(3, 40, 3),
      ]
      const createTimeAxis = (axis, display, min, max) => ({
        id: `time-axis-${axis}`,
        type: 'time',
        time: {
          tick: 'day',
        },
        ticks: {
          min: min,
          max: max,
        },
        display: display,
        stacked: true,
        gridLines: {
          offsetGridLines: true,
        },
      })

      const cChart1 = new Chart('cChart1', {
        type: 'bar',
        data: {
          datasets: [
            infectionLineDataset,
            infectionBarDataset,
            trendlineDataset,
            trendbarDataset,
            predictionLineDatasets[0],
            predictionLineDatasets[1],
            predictionLineDatasets[2],
            predictionBarDatasets[0],
            predictionBarDatasets[1],
            predictionBarDatasets[2],
          ],
        },
        options: {
          title: {
            text: labels.chart,
            display: true,
          },
          legend: {
            position: 'bottom',
            labels: {
              generateLabels: ({ config }) =>
                config.data.datasets
                  .filter(dataset => 'legend' in dataset)
                  .map(dataset => dataset.legend),
            },
          },
          scales: {
            xAxes: [
              createTimeAxis(0, true, moment(), moment().add(1, 'months')),
              createTimeAxis(1, false, moment(), moment().add(1, 'months')),
              createTimeAxis(2, false, moment(), moment().add(1, 'months')),
              createTimeAxis(3, false, moment(), moment().add(1, 'months')),
            ],
            yAxes: [
              {
                id: 'total-axis',
                scaleLabel: {
                  labelString: labels.line,
                  display: true,
                },
                type: 'logarithmic',
                position: 'right',
                ticks: {
                  autoSkip: false,
                  callback: tick => {
                    if (tick / Math.pow(10, Math.floor(Math.log10(tick))) === 1)
                      return tick.toString()
                    return ''
                  },
                  min: 1,
                  max: 6000000,
                },
              },
              {
                id: 'new-axis',
                display: true,
                stacked: true,
                scaleLabel: {
                  labelString: labels.bars,
                  display: true,
                },
                type: 'linear',
                position: 'left',
                ticks: {
                  callback: tick => {
                    if (tick % 250 === 0) return tick.toString()
                    return ''
                  },
                  min: 0,
                  max: 1500 + Math.log10(6) * 250,
                  stepSize: 250,
                  beginAtZero: true,
                },
                stacked: false,
              },
            ],
          },
        },
      })

      const cChart2 = new Chart('cChart2', {
        type: 'bar',
        data: {
          datasets: [
            infectionLineDataset,
            infectionBarDataset,
            trendlineDataset,
            trendbarDataset,
            predictionLineDatasets[0],
            predictionLineDatasets[1],
            predictionLineDatasets[2],
            predictionBarDatasets[0],
            predictionBarDatasets[1],
            predictionBarDatasets[2],
          ],
        },
        options: {
          title: {
            text: labels.chart,
            display: false,
          },
          legend: {
            position: 'bottom',
            display: false,
            labels: {
              generateLabels: ({ config }) =>
                config.data.datasets
                  .filter(dataset => 'legend' in dataset)
                  .map(dataset => dataset.legend),
            },
          },
          scales: {
            xAxes: [
              createTimeAxis(0, true, moment(), moment().add(1, 'months')),
              createTimeAxis(1, false, moment(), moment().add(1, 'months')),
              createTimeAxis(2, false, moment(), moment().add(1, 'months')),
              createTimeAxis(3, false, moment(), moment().add(1, 'months')),
            ],
            yAxes: [
              {
                id: 'total-axis',
                scaleLabel: {
                  labelString: labels.line,
                  display: true,
                },
                type: 'logarithmic',
                position: 'right',
                ticks: {
                  autoSkip: false,
                  callback: tick => {
                    if (tick / Math.pow(10, Math.floor(Math.log10(tick))) === 1)
                      return tick.toString()
                    return ''
                  },
                  min: 1,
                  max: 6000000,
                },
              },
              {
                id: 'new-axis',
                display: true,
                stacked: true,
                scaleLabel: {
                  labelString: labels.bars,
                  display: true,
                },
                type: 'linear',
                position: 'left',
                ticks: {
                  callback: tick => {
                    if (tick % 50000 === 0) return tick.toString()
                    return ''
                  },
                  min: 0,
                  max: 300000 + Math.log10(6) * 50000,
                  stepSize: 50000,
                  beginAtZero: true,
                },
                stacked: false,
              },
            ],
          },
        },
      })

      $.get(
        'https://w3qa5ydb4l.execute-api.eu-west-1.amazonaws.com/prod/finnishCoronaData',
        data => {
          const makeBars = line =>
            line.map((value, i) => ({
              t: moment(value.t),
              y: i === 0 ? value.y : value.y - line[i - 1].y,
            }))
          let iLine = Array.from(
            data.confirmed
              .sort((a, b) => new Date(a.date) - new Date(b.date))
              .slice(1)
              .reduce(
                (cMap, confirmed, i) =>
                  cMap.set(
                    new Date(confirmed.date).setHours(0, 0, 0, 0),
                    i + 1
                  ),
                new Map()
              ),
            ([date, confirmed]) => ({ t: moment(date), y: confirmed })
          ).sort((a, b) => a.t - b.t)
          let iBars = makeBars(iLine)
          let tData = iLine.map(value => ({
            x: value.t.diff(iLine[0].t, 'days'),
            y: Math.log10(value.y),
          }))
          let tSlope =
            (tData.length *
              tData.reduce((sum, data) => sum + data.x * data.y, 0) -
              tData.reduce((sum, data) => sum + data.x, 0) *
                tData.reduce((sum, data) => sum + data.y, 0)) /
            (tData.length *
              tData.reduce((sum, data) => sum + data.x * data.x, 0) -
              Math.pow(
                tData.reduce((sum, data) => sum + data.x, 0),
                2
              ))
          let tOffset =
            (tData.reduce((sum, data) => sum + data.y, 0) -
              tSlope * tData.reduce((sum, data) => sum + data.x, 0)) /
            tData.length
          let tCutoff = Math.floor(
            (Math.log10(population / 2) - tOffset) / tSlope
          )
          let tLine = Array.from(
            {
              length: moment()
                .add(predictMonths, 'months')
                .diff(iLine[0].t, 'days'),
            },
            (n, i) => ({
              t: moment(iLine[0].t).add(i, 'days'),
              y: Math.floor(
                i <= tCutoff
                  ? Math.pow(10, i * tSlope + tOffset)
                  : 2 * Math.pow(10, tCutoff * tSlope + tOffset) -
                      Math.pow(10, (2 * tCutoff - i) * tSlope + tOffset)
              ),
            })
          )
          let tBars = makeBars(tLine)

          infectionLineDataset.data = iLine
          infectionBarDataset.data = iBars
          trendlineDataset.data = tLine
          trendbarDataset.data = tBars

          trendlineDataset.legend.text = `${labels.trend}, ${
            labels.growth
          } ${Math.round(tSlope * 100)}%`

          const predictLine = ({ infectionPercentage, infectionRate }) => {
            let iNow = moment().diff(tLine[0].t, 'days')
            let pSlope = infectionRate / 100
            let pStart = Math.floor(
              (Math.log10(iLine[iLine.length - 1].y) - tOffset) / pSlope
            )

            let pOffset =
              iLine[iLine.length - 1].y -
              Math.pow(10, pStart * pSlope + tOffset)

            let pCutoff = Math.floor(
              (Math.log10((population * infectionPercentage) / 200) - tOffset) /
                pSlope
            )

            pLine = Array.from(
              {
                length: moment()
                  .add(predictMonths, 'months')
                  .diff(moment(), 'days'),
              },
              (n, i) => ({
                t: moment()
                  .startOf('day')
                  .add(i, 'days'),
                y: Math.floor(
                  i + pStart <= pCutoff
                    ? Math.pow(10, (i + pStart) * pSlope + tOffset) + pOffset
                    : 2 * Math.pow(10, pCutoff * pSlope + tOffset) -
                        Math.pow(
                          10,
                          (2 * pCutoff - (i + pStart)) * pSlope + tOffset
                        ) +
                        pOffset
                ),
              })
            )
            return pLine
          }
          predictionLineDatasets.forEach(
            dataset => (dataset.data = predictLine(dataset))
          )
          predictionBarDatasets.forEach((dataset, i) => {
            dataset.data = makeBars(predictionLineDatasets[i].data).splice(1)
          })

          let min = moment(iLine[0].t)
          let max1 = moment()
            .add(1, 'months')
            .add(-1, 'days')
          let max2 = moment()
            .add(predictMonths, 'months')
            .add(-1, 'days')

          cChart1.options.scales.xAxes = [
            createTimeAxis(0, true, min, max1),
            createTimeAxis(1, false, min, max1),
            createTimeAxis(2, false, min, max1),
            createTimeAxis(3, false, min, max1),
          ]
          cChart1.update()

          cChart2.options.scales.xAxes = [
            createTimeAxis(0, true, min, max2),
            createTimeAxis(1, false, min, max2),
            createTimeAxis(2, false, min, max2),
            createTimeAxis(3, false, min, max2),
          ]
          cChart2.update()
        }
      )
    </script>
  </body>
</html>
